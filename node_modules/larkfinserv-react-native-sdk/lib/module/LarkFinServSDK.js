import axios from 'axios';
import { Linking } from 'react-native';
import { getSDKUrl, getSDKApiUrl, DEFAULT_HEADERS } from './config/constants';
import { encodeBase64 } from './utils/base64';
class LarkFinServSDK {
  eventHandlers = new Map();
  iframeUrl = '';
  sessionToken = '';
  constructor(config) {
    this.config = config;
    this.validateConfig();
    this.generateSessionToken();
  }

  /**
   * Initialize the SDK with partner configuration
   */
  async initialize(config) {
    try {
      // Merge incoming config with existing config
      this.config = {
        ...this.config,
        ...config
      };

      // Validate required configuration
      if (!this.config.apiKey || !this.config.apiSecret) {
        throw new Error('Missing required configuration: apiKey and apiSecret are required');
      }
      let endpoint = `${getSDKApiUrl(this.config.environment)}/loan-sdk/init`;
      if (this.config.phoneNumber) {
        endpoint = `${endpoint}?phone=${this.config.phoneNumber}&isVerified=${true}`;
      }

      // Make API request
      const response = await axios.get(endpoint, {
        headers: {
          ...DEFAULT_HEADERS,
          'X-SDK-Key': this.config.apiKey,
          'X-SDK-Secret': this.config.apiSecret
        },
        timeout: 10000
      });

      // Validate response structure
      if (!response.data || !response.data.sessionId || !response.data.themeConfig) {
        throw new Error('Invalid response structure from initialization API');
      }

      // Map user.id to userId explicitly
      const userId = response.data.user?.id || response.data.userId || this.config.userId;

      // Update configuration
      this.config = {
        ...this.config,
        theme: response.data.themeConfig,
        sessionId: response.data.sessionId,
        partnerName: response.data.partnerName,
        partnerId: response.data.partnerId,
        userId: userId,
        currentJourneyStep: response.data.currentJourneyStep,
        stepProgressSummary: response.data.stepProgressSummary,
        hasActiveLoan: response.data.hasActiveLoan,
        loanDetails: response.data.loanDetails,
        requiresEmailVerification: response.data.requiresEmailVerification
      };

      // Submit consents if provided
      if (this.config.consentData && this.config.userId) {
        await this.submitConsentData();
      }
      this.iframeUrl = this.generateIframeUrl();
    } catch (error) {
      let errorMessage = 'Failed to initialize SDK';
      if (axios.isAxiosError(error)) {
        if (error.response) {
          errorMessage += `: ${error.response.status} - ${error.response.data?.message || 'No error message'}`;
        } else if (error.request) {
          errorMessage += ': No response received from server';
        } else {
          errorMessage += `: ${error.message}`;
        }
      } else if (error instanceof Error) {
        errorMessage += `: ${error.message}`;
      }
      console.error(errorMessage, error);
      throw new Error(errorMessage);
    }
  }

  /**
   * Get the generated iframe URL (for WebView)
   */
  getIframeUrl() {
    return this.iframeUrl;
  }

  /**
   * Get the current configuration
   */
  getConfig() {
    return this.config;
  }

  /**
   * Open eligibility check in external browser (popup mode)
   */
  async openEligibilityCheck(mode) {
    if (!this.iframeUrl) {
      throw new Error('SDK not initialized. Call initialize() first.');
    }

    // Submit consents before opening if not already done
    if (this.config.consentData && this.config.userId) {
      await this.submitConsentData();
    }
    if (mode === 'popup') {
      const supported = await Linking.canOpenURL(this.iframeUrl);
      if (supported) {
        await Linking.openURL(this.iframeUrl);
        this.emitEvent('INITIATED');
      } else {
        throw new Error(`Cannot open URL: ${this.iframeUrl}`);
      }
    } else {
      // For inline/embedded modes, the parent app handles WebView rendering
      this.emitEvent('INITIATED');
    }
  }

  /**
   * Register an event handler
   */
  on(event, handler) {
    this.eventHandlers.set(event, handler);
  }

  /**
   * Unregister an event handler
   */
  off(event) {
    this.eventHandlers.delete(event);
  }

  /**
   * Handle message from WebView
   */
  handleWebViewMessage(message) {
    try {
      const data = JSON.parse(message);
      if (!data?.type) return;
      switch (data.type) {
        case 'READY':
          this.emitEvent('READY');
          break;
        case 'ELIGIBILITY_RESULT':
          this.emitEvent('ELIGIBILITY_RESULT', data.data);
          break;
        case 'ERROR':
          this.emitEvent('ERROR', {
            error: data.data.error
          });
          break;
        case 'CLOSE':
          this.emitEvent('CLOSE');
          break;
        case 'CLOSE_FRAME':
          this.emitEvent('CLOSE_FRAME', data.data);
          break;
        case 'JOURNEY_STEP_COMPLETED':
          this.emitEvent('JOURNEY_STEP_COMPLETED', data.data);
          break;
        case 'SESSION_CLEARED':
          this.emitEvent('SESSION_CLEARED', data.data);
          break;
      }
    } catch (error) {
      console.error('Error handling WebView message:', error);
    }
  }

  /**
   * Send data to WebView
   */
  createWebViewMessage(data) {
    return JSON.stringify({
      type: 'USER_DATA_UPDATE',
      data,
      metadata: {
        partnerId: this.config.partnerId
      }
    });
  }

  /**
   * Clear session
   */
  clearSession() {
    this.emitEvent('SESSION_CLEARED', {
      reason: 'manual',
      timestamp: new Date().toISOString()
    });
  }

  /**
   * Get session information
   */
  getSessionInfo() {
    return {
      hasSessionId: !!this.config.sessionId,
      hasUserId: !!this.config.userId,
      hasPhoneNumber: !!this.config.phoneNumber,
      sessionId: this.config.sessionId,
      userId: this.config.userId
    };
  }

  // Private methods

  validateConfig() {
    if (!this.config.apiKey || !this.config.apiSecret) {
      throw new Error('Missing required configuration: apiKey and apiSecret are required');
    }
  }
  generateSessionToken() {
    const data = JSON.stringify({
      partnerId: this.config.partnerId,
      timestamp: Date.now(),
      ttl: 3600
    });
    // React Native compatible base64 encoding
    this.sessionToken = encodeBase64(data);
  }
  generateIframeUrl() {
    const baseUrl = getSDKUrl(this.config.environment);
    const params = [];
    params.push(`authKey=${encodeURIComponent(this.config.apiKey)}`);
    if (this.config.apiSecret) {
      params.push(`authSecret=${encodeURIComponent(this.config.apiSecret)}`);
    }
    if (this.config.sessionId) {
      params.push(`sessionId=${encodeURIComponent(this.config.sessionId)}`);
    }
    if (this.config.partnerId) {
      params.push(`partnerId=${encodeURIComponent(this.config.partnerId)}`);
    }
    if (this.config.userId) {
      params.push(`userId=${encodeURIComponent(this.config.userId)}`);
    }
    if (this.config.theme) {
      params.push(`theme=${encodeURIComponent(JSON.stringify(this.config.theme))}`);
    }
    if (this.config.phoneNumber) {
      params.push(`phoneNumber=${encodeURIComponent(this.config.phoneNumber)}`);
    }
    return `${baseUrl}?${params.join('&')}`;
  }
  emitEvent(eventType, data) {
    const handler = this.eventHandlers.get(eventType);
    if (handler) {
      handler({
        type: eventType,
        data: data || {}
      });
    }
  }
  async getClientIP() {
    try {
      const response = await axios.get('https://api.ipify.org?format=json', {
        timeout: 5000
      });
      return response.data.ip;
    } catch {
      return 'unknown';
    }
  }
  async submitConsentData() {
    if (!this.config.consentData) {
      return;
    }
    if (!this.config.userId) {
      return;
    }
    if (!this.config.sessionId) {
      return;
    }
    try {
      const consentPayload = {
        userId: this.config.userId,
        sessionId: this.config.sessionId,
        provider: this.config.partnerId || 'UNKNOWN',
        privacyConsent: this.config.consentData.privacyConsent,
        promotionalConsent: this.config.consentData.promotionalConsent,
        ipAddress: await this.getClientIP(),
        userAgent: 'React Native SDK',
        deviceFingerprint: 'mobile'
      };
      const response = await axios.post(`${getSDKApiUrl(this.config.environment)}/loan-sdk/consents/submit`, consentPayload, {
        headers: {
          ...DEFAULT_HEADERS,
          'X-SDK-Key': this.config.apiKey,
          'X-SDK-Secret': this.config.apiSecret
        },
        timeout: 10000
      });
      if (response.data.success) {
        console.log('Consents submitted successfully');
      }
    } catch (error) {
      console.error('Failed to submit consents:', error);
    }
  }
}
export default LarkFinServSDK;
//# sourceMappingURL=LarkFinServSDK.js.map